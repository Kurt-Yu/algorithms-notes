# 前缀和与差分

## 前缀和 Prefix Sum
前缀和通常用来解决这类问题：给定一个数组和 m 个询问，每次询问需要我们求出在区间`[l, r]`里所有元素的和。对于这类问题，我们当然可以暴力求解每个区间的和，从 l 到 r 遍历一遍即可。每次求解花费 `O(n)`时间，总共 m 次询问的时间复杂度为`O(nm)`。

前缀和的意思是，我们可以对数组进行预处理，从而达到降低时间复杂度的目的。注意到：区间`[l, r]`所有数字的和等于`Sum([0, r]) - Sum([0, l - 1])`，即区间 0 到 r 的所有数字的和减去 0 到 l 的所有数字的和。因此我们可以从原数组预处理得到如下的数组：
```cpp
// 原数组
s[0], s[1], s[2], s[3], ......
// 预处理数组：
prefix[0] = a[0], prefix[1] = a[0] + a[1], prefix[2] = a[0] + a[1] + a[2], ..... 
```
使得每个元素等于`a[0]`到`a[i]`所有数字的和，那么区间`[l, r]`的和即为`prefix[r] - prefix[l - 1]`。

```cpp
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &s[i]);
    for (int i = 1; i <= n; ++i) s[i] += s[i - 1];
    for (int i = 0; i < m; ++i) {
        scanf("%d%d", &l, &r);
        if (l == 0) printf("%d\n", s[r]);
        else printf("%d\n", s[r] - s[l - 1]);
    }
    return 0;
}
```

### 二维前缀和

上述的思路同样也可以应用到二维数组里：给定一个二维数组和 q 次查询，每次查询要求出以左上角`(x1, y1)`和右下角`(x2, y2)`所构成的矩形里所有元素的和。我们同样也可以构建上述的 prefix 数组，使得：
```cpp
sum = prefix[x2][y2] - prefix[x2][y1 - 1] - preifx[x1 - 1][y2] + prefix[x1 - 1][y1 - 1]
```
因为左上角那块小矩形被减了两次，所以最后要加回来。以下是完整代码：
```cpp
int n, m, q;
int s[N][N];

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            scanf("%d", &s[i][j]);
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; 
        }
    }
    
    for (int i = 0; i < q; ++i) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]); 
    }
}
```
?> 注意在前缀和的题目里，我们经常从 1 开始索引，而不是从 0，这样可以避免一些边界条件的判断。

## 差分
差分是前缀和的逆运算。给定一个数组 a，我们要构建这样一个数组 b，使得：
```
a[i] = b[0] + b[1] + b[2] + ... + b[i]
```
那么 a 称为 b 的前缀和，b 称为 a 的差分。差分通常用来解决这样的问题：给定数组 a，和 m 个操作，每个操作包含三个整数l, r, c，表示将序列中`[l, r]`之间的每个数加上`c`。求所有这些操作结束后数组的值。当然我们可以暴力求解，这样每次操作的时间为`O(n)`，但是利用我们上述构建的差分数组 b，可以把时间复杂度降为`O(1)`。

因为 a 是 b 的前缀和，要把`[l, r]`之间的每个数加上`c`，我们只需要把`b[l] + c`即可，因为
```
a[l] = b[0] + b[1] + ... b[l]
a[l + 1] = b[0] + b[1] + ... b[l] + b[l + 1]
...
a[r] = b[0] + b[1] + ... b[l] + ... + b[r]
```
注意到从`a[l]`到`a[r]`，每个数都包含`b[l]`，我们把`b[l] + c`，则等同于 `[l, r]`里的每个数都加上了 c，但是我们不需要 r 之后的数字也加上 c，所以`b[r + 1] - 1`，意味着从`r + 1`开始往后的每个数都减 c，用来抵消之前的加 c。

总结一下，差分的核心思路在于这两行：`b[l] + c;  b[r + 1] - c`。所有操作结束后，对 b 求前缀和，即得到原数组。

那么问题来了，如何构建这样一个差分数组 b 呢？其实很简单，我们只需要把每个数`b[i]`看做是对`[i,i]`的区间里的数加`a[i]`。具体代码如下：
```cpp
int n, m, l, r, c;
int a[N];   // 原数组
int b[N];   // 我们构建的差分数组

void insert(int l, int r, int c) {
    b[l] += c;
    b[r + 1] -= c;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        insert(i, i, a[i]);
    }
    
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d%d", &l, &r, &c);
        insert(l, r, c);
    }
    
    for (int i = 1; i <= n; ++i) {
        b[i] += b[i - 1];
        printf("%d ", b[i]);
    }
    return 0;
}
```
?> 差分和前缀和是一对逆运算，就如同积分和微分一样。差分通常不太好理解，可以多花点时间来琢磨一下，它的思路比较巧妙，但代码量不大，因此也是面试里常考的一种题型。当然，对于这种问题线段树也可以求解，我们在之后的章节再来细说。

### 二维差分

问题描述：输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数`x1, y1, x2, y2, c`，其中`(x1, y1)`和`(x2, y2)`表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上c。求所有操作结束后数组的值。

二维差分的思路和二维前缀和大同小异，都是维护那几个矩形的相互关系，在二维差分里，我们需要这样 update 差分数组：
```cpp
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```
`b[x1][y1] += c`表示的是所有在点`(x1, y1)`之后的点(所谓的“之后的点”，即以该点作为左上角，数组最后一个点作为右下角所构成的矩形)都会加上 c，`b[x2 + 1][y1]`和`b[x1][y2 + 1]`所代表的矩形不应该加上 c，所以减去 c，来抵消之前加的 c，`b[x2 + 1][y2 + 1]`所代表的的矩形被减了两次，所以加上 c，补偿回来。整个代码实现：
```cpp
const int N = 1010;

int n, m, q;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

int main() {
    scanf("%d%d%d", &n, &m, &q);
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            scanf("%d", &a[i][j]);
            insert(i, j, i, j, a[i][j]);
        }
    }
    
    for (int i = 0; i < q; ++i) {
        int x1, y1, x2, y2, c;
        scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &c);
        insert(x1, y1, x2, y2, c);
    }
    
    // 通过 b 求前缀和得到原数组
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            printf("%d ", b[i][j]);
        }
        puts("");
    }
    
    return 0;
}
```